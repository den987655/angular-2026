
**ГЛАВА 2.**  
Четыре уровня архитектуры фронтенда

Чтобы наконец перестать тонуть в спорах о «правильных структурах», нужно принять одну простую истину:

Современное приложение состоит из нескольких чётко разделённых уровней архитектуры.  
У каждого уровня — своя ответственность.  
Когда уровни смешиваются → хаос.  
Когда разделяются → порядок, предсказуемость и масштабируемость.

Фронтенд в 2025+ — это уже не «компоненты + роуты».  
Это полноценная многослойная система.

В этой главе мы вводим четыре уровня, которые образуют каркас всей книги и реально работают на проектах любого масштаба — от маркетплейсов до enterprise-панелей.

1. Уровень структуры проекта (Project Structure Layer)  
2. Прикладная и доменная архитектура (Application / Domain Layer)  
3. Внутрифичевая архитектура (Feature Internal Design Layer)  
4. Runtime / Delivery Layer

**1. Уровень структуры проекта (Project Structure Layer)**

Самый верхний, видимый уровень.  
Отвечает за навигацию по кодовой базе.

Вопросы, на которые он решает:
- Как разложены папки?
- Где лежат фичи, shared, страницы, роуты?
- Как быстро новичок поймёт, где что находится?

Главное деление 2025 года:

Type-based (устаревший подход)
```
src/
  components/
  services/
  models/
  pipes/
  guards/
  pages/
```
Проблемы: всё перемешано → огромные папки → потеря контекста → высокая когнитивная нагрузка → невозможно делить ответственность между командами.

Feature-based (современный стандарт)
```
/features
  /catalog
    /ui
    /components
    /pages
    /data-access
    /state
    /model
    /services
    /catalog.routes.ts
  /cart
  /order
  /profile

/shared
  /ui
  /utils
  /core
```
Вертикальный срез: одна фича = одна папка = один контекст.  
Фичу видно целиком, её можно вынести, можно отдать отдельной команде.

Этот уровень — не про DDD и не про паттерны.  
Это просто порядок в файлам.  
Если здесь бардак — дальше будет только хуже.

**2. Прикладная и доменная архитектура (Application / Domain Layer)**

Глубже и важнее.  
Это мозг приложения.

Решает вопросы:
- Какие доменные сущности существуют?
- Где живут бизнес-правила?
- Что относится к домену, а что к инфраструктуре?
- Как организован поток данных?

На фронтенде нам не нужен DDD «в чистом виде» с агрегатами и bounded contexts.  
Но идея разделения домена и инфраструктуры обязательна.

Без неё получаем то же, что бэкенд получил 10–15 лет назад:
- бизнес-логика размазана по компонентам,
- HTTP-клиенты проникают повсюду,
- модели привязаны к ответам API,
- смена бэкенда ломает весь фронт.

Правильное разделение даёт:
- устойчивость к изменениям API,
- тестируемость,
- предсказуемость,
- возможность переиспользования доменной логики.

Что относится к этому уровню в 2025:

1. Domain модели (Product, CartItem, Order и т.д.)
2. Use cases / Application services — операции вида loadProducts(), addToCart(), checkout()
3. Фасады/оркестраторы — связывают API, store, навигацию, события
4. Repository / Data-access layer — преобразует сырые DTO в доменные модели
5. Feature-уровневые или глобальные стоны — хранят доменное состояние

Это и есть «приложение», а не просто «UI с кнопочками».

**3. Архитектура внутри фичи (Feature Internal Design Layer)**

Локальный уровень.  
Отвечает за внутреннее устройство одной фичи.

Вопросы:
- Где состояние фичи?
- Где её API-клиенты?
- Как компоненты общаются между собой?
- Как фича остаётся автономной?

Здесь живут:

1. Сигналы и реактивный слой фичи  
   - локальный UI-state  
   - вычисляемые значения  
   - feature-store (signal store или NgRx SignalStore)

2. Фасад-сервис фичи (CatalogFacade, CartFacade)  
   - загрузка данных  
   - применение фильтров  
   - обработка ошибок и лоадеров  
   - побочные эффекты

3. Data-access слой внутри фичи  
   - HTTP-адаптеры  
   - мапперы DTO → Domain  
   - кэширование

4. UI и страницы фичи  
   - атомарные компоненты  
   - страницы и роуты

Фича становится маленьким самостоятельным приложением внутри большого.  
Её можно вынести в отдельный репозиторий, npm-пакет или микрофронтенд почти без боли.

Это и есть настоящая модульность 2025 года.

**4. Runtime / Delivery Layer**

Уровень, о котором забывают 90 % разработчиков, пока проект не начнёт тормозить на мобильных устройствах.

Вопросы:
- Как рендерится первый кадр?
- Что выполняется на сервере, а что на клиенте?
- Когда и как происходит гидрация?
- Сколько JavaScript реально приходит пользователю?

Виды рендеринга 2025:

1. CSR — классический SPA (умирает)
2. SSR — HTML с сервера
3. SSG / Prerender — статика на билде
4. Streaming SSR + Partial (incremental) hydration — только нужные части оживают

Server-first подход стал доминирующим, потому что определяет:
- Core Web Vitals,
- SEO,
- время до первого взаимодействия,
- объём передаваемого JS,
- стратегию загрузки данных.

Именно runtime-слой делает фронтенд настоящей delivery-платформой, а не игрушкой в браузере.

**Зачем нужны эти четыре уровня?**

Потому что:

- Фича-ориентированная структура — только уровень 1  
- Signal Store / фасады / репозитории — уровни 2–3  
- SSR, hydration, resumability — уровень 4

Когда уровни путаются → компоненты раздуваются, зависимости запутываются, стоны становятся монстрами, перформанс падает.

Когда разделены → структура читается как книга, зависимости однонаправленные, проект растёт без деградации.

**Итог главы 2**

Сигнал  
Фронтенд 2025+ — это четыре чётко разделённых уровня: структура → домен/приложение → внутренности фичи → runtime.

Ключевая парадигма  
Чистое разделение ответственности по уровням.

Системные последствия  
- Легко масштабировать команду  
- Просто тестировать и поддерживать  
- Фичи становятся переносимыми  
- Проект не деградирует со временем  
- Перформанс и SEO на высоком уровне по умолчанию

Практические шаги прямо сейчас  
1. Наведите порядок в структуре папок (переход на feature-based)  
2. Выделите доменные модели и use cases  
3. Внедрите фасады и signal-стоны на уровне фич  
4. Подготовьте проект к SSR/hydration (даже если пока CSR)

Риски  
- Переусложнение маленьких проектов  
- Слепое копирование «enterprise»-подходов  
- Игнорирование runtime-слоя («потом сделаем SSR»)

Что следить в 2025–2026  
- Углубление partial hydration в Angular и React  
- Развитие SignalStore и аналогичных решений  
- Инструменты автоматической миграции на feature-based структуру  
- Стабилизация streaming SSR и resumability-подходов