**ГЛАВА 10.**  
Антипаттерны и чек-листы: как не разрушить проект, даже зная хорошие подходы

**Введение**  
Даже если структура выглядит как feature-based, есть сигналы, фасады, SSR и SignalStore — проект всё равно может медленно умирать.

Почему?  
Архитектура — это не только папки, это решения людей.  
Антипаттерны рождаются из одних и тех же причин:

- лень подумать над правильным уровнем абстракции,  
- «срочная» фича любой ценой,  
- имитация грамотной архитектуры без реального понимания слоёв.

Эта глава — коллекция самых частых и смертоносных ошибок 2025 года + чек-листы, которые помогут диагностировать их на ранней стадии.

**1. Антипаттерн: «Божественный Store»**

Симптомы  
Один глобальный Store (чаще всего NgRx или SignalStore в корне), в котором:

- весь доменный стейт приложения,  
- UI-флаги (модалки, табы, loading),  
- кэш всех API,  
- фильтры, корзина, профиль, настройки,  
- бизнес-правила и эффекты.

Почему появляется  
- «удобно видеть всё в DevTools»,  
- страх «потерять контроль»,  
- «так быстрее связать две фичи».

Последствия  
- любое изменение — риск сломать половины приложения,  
- команда не может работать параллельно,  
- SSR ломается в неожиданных местах,  
- размер бандла и сложность растут экспоненциально.

Лечение  
1. Вынести каждую фичу в свой SignalStore.  
2. Глобальный Store оставить только для auth + settings (максимум 15–20 полей).  
3. Кэшировать API в фиче, а не глобально.  
4. UI-стейт — никогда в Store.

**2. Антипаттерн: «Компонент-бог»**

Симптомы  
Компонент > 400 строк, делает всё сразу:

- рендерит,  
- держит состояние,  
- вызывает API напрямую,  
- содержит бизнес-логику,  
- управляет навигацией,  
- подписывается на глобальные события.

Почему появляется  
- быстрый прототип → «потом порефакторим» (никогда),  
- нет дисциплины,  
- один разработчик пишет фичу целиком.

Последствия  
- невозможно тестировать,  
- невозможно переиспользовать,  
- SSR падает (window is undefined),  
- перформанс деградирует (лишние перерендеры).

Лечение  
UI + локальные сигналы — в компоненте.  
Всё остальное — наружу (фасад/стор/domain).

**3. Антипаттерн: «Shared-свалка»**

Симптомы  
В shared/ лежит:

- UI-компоненты с бизнес-логикой,  
- хелперы, которые знают о конкретных фичах,  
- модели с валидацией,  
- сервисы,  
- даже state или domain-логика.

shared импортируется везде → граф зависимостей как новогодняя гирлянда.

Последствия  
Циклические зависимости, невозможность вынести фичу, рефакторинг — ад.

Лечение  
shared = только pure UI + чистые утилиты.  
Если компонент знает о бизнесе — ему место в фиче.  
Если утилита работает с конкретной моделью — в фиче.

**4. Антипаттерн: «Псевдо-feature-based» (фича-папки без границ)**

Симптомы  
Папки есть, но:

- catalog/state импортирует cart/state напрямую,  
- product/ui использует cart.facade прямо,  
- в catalog.page.ts есть import из ../../cart/services.

Выглядит красиво, работает как старый SPA.

Последствия  
Фичи не автономны → нельзя вынести → нельзя отдать другой команде → масштабирование невозможно.

Лечение  
- каждая фича имеет index.ts — единственный публичный вход,  
- запрещён импорт чего-либо из чужой фичи кроме её index.ts,  
- если нужна связь — только через глобальный store или события (ред.

**5. Антипаттерн: «Фасад — новый бог»**

Симптом  
Фасад 500–800 строк, делает всё: API, маппинг, бизнес-правила, состояние, навигацию.

Он стал тем, чем был сервис в 2020.

Лечение  
Фасад — тонкий оркестратор (обычно < 150 строк).  
Всё тяжёлое — в store или domain.

**6. Антипаттерн: «Коллекция микросервисов на фронте»**

Каждый разработчик/команда делает свой:

- HttpClient с своими интерцепторами,  
- свой error-handling,  
- свой способ кэширования,  
- свои базовые модели.

В проекте 7 разных способов сделать запрос и 5 способов обработать 401.

Лечение  
core/api — единая платформа (интерцепторы, error-service, retry, cache).  
Фичи — только используют, не переопределяют.

**7. Антипаттерн: «SSR через боль»**

Симптомы  
- SSR включили, но половина страниц крашится (window is undefined),  
- дублирование инициализации (и на сервере, и на клиенте),  
- гидрация ошибок на проде,  
- перформанс хуже, чем был CSR.

Причина — SSR включили в конце, когда проект уже большой.

Лечение  
- проектировать под SSR с первого дня (даже если пока CSR),  
- isPlatformServer / Browser checks только в крайних случаях,  
- @defer и partial hydration на тяжёлых частях.

**Чек-листы (самый полезный кусок главы)**

**Чек-лист структуры**

1. Глобальный Store < 20 полей  
2. Каждая фича имеет index.ts  
3. Нет импортов из чужих фич кроме index.ts или shared  
4. shared/ui — stateless  
5. Фасад < 200 строк  
6. Нет прямых HttpClient в компонентах  
7. UI-state только в компоненте  
8. Фичевое состояние — в SignalStore  
9. Страницы — внутри фич  
10. Lazy-load по фичам  

Если хотя бы 2 пункта — красный флаг.

**Чек-лист стейта**

- UI-state = локальные сигналы компонента  
- Фич-state = SignalStore фичи  
- Глобал = только auth + settings/theme/locale  
- Нет дублирования (state в сторе и в фасаде одновременно)  
- Эффекты только в SignalStore.withEffects  

**Чек-лист SSR/server-first**

- Проект билдится с --ssr без ошибок  
- SEO-страницы — SSR или SSG  
- Тяжёлые компоненты в @defer  
- Нет window/document в OnInit/PUSH  
- transferState используется для данных  

**Чек-лист онбординга новичка**

Новичок за 4 часа может:

- найти страницу по URL,  
- понять, где состояние фичи,  
- добавить кнопку в корзину на странице товара,  
- запустить проект локально.

Если нет — архитектура уже больна.

**Итог главы 10**

**Сигнал**  
Даже идеальная на вид структура не спасёт, если внутри — старые антипаттерны.  
Главный враг 2025 — не отсутствие архитектуры, а её имитация.

**Ключевая парадигма**  
Границы, границы и ещё раз границы.  
Фича = автономный модуль с публичным API.  
Фасад = тонкий.  
Store = локальный.  
Shared = pure.

**Системные последствия**  
- Проект перестаёт деградировать со временем  
- Команда растёт без конфликтов  
- Рефакторинг = удаление папки  
- SSR работает "из коробки"

**Практические шаги прямо сейчас**

1. Провести аудит по чек-листам (всей команде).  
2. Выбрать самый больной антипаттерн и убить его за спринт.  
3. Ввести code-review правило: "Где фасад этой фичи?" и "Почему это в shared?"  
4. Назначить архитектурного "царя границ" (кто мержит только чистый код).

**Риски**  
- Переусложнение ("давайте всё в DDD сразу")  
- Фанатизм ("SignalStore везде, даже для isOpen")  
- "Потом порефакторим"  

**Что следить в 2026**  
- Автоматические анализаторы границ (Nx enforced + ESLint)  
- Angular schematics для генерации правильных фич  
- AI-code-review инструменты на границах и антипаттернах