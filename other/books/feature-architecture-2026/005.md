**ГЛАВА 5.**  
Роуты и страницы: карта приложения, а не свалка компонентов

Если фича — это модуль смысла, то страница — это точка входа в этот смысл.

Исторически страницы во фронтенде часто превращались в свалку: где-то в `/pages`, где-то в `/components`, где-то размазаны по модулям. Имя файла не совпадает с URL, роутер — хаотичный список, а новичок не может найти, где живёт «Оформление заказа».

Когда приложение растёт, именно навигация становится каркасом, который держит всю систему.  
Страница — это не просто «компонент с большим шаблоном».  
Страница — это маршрут, контекст, точка входа и публичный контракт фичи.

Эта глава ставит всё на места: где живут страницы, как устроен роутер и как сделать карту приложения, которую можно читать как схему метро.

**1. Страница = маршрут. Точка входа, а не «просто компонент»**

В современной архитектуре страница — это:

- единица навигации (`/catalog`, `/product/:id`, `/cart`),
- контейнер одной или нескольких фич,
- конкретный layout,
- контекст данных (resolve, preload),
- место, где начинается UI-срез фичи.

Страница — это не UI-блок.  
Страница — вход в комнату, а не кирпич стены.

Компонент ≠ страница.  
Компонент — кирпич.  
Страница — дверь с табличкой.

**2. Страницы живут только внутри фичи**

Обязательное правило feature-based структуры:

```
/features
  /catalog
    /pages
      catalog.page.ts
      product-details.page.ts
    /catalog.routes.ts
  /cart
    /pages
      cart.page.ts
    /cart.routes.ts
  /auth
    /pages
      login.page.ts
      register.page.ts
    /auth.routes.ts
```

Никаких глобальных `src/app/pages/`.

Почему:

- страницу ищут по URL, а не по имени компонента,
- фича должна быть полностью автономной и переносимой,
- когда страница лежит вне фичи — фича перестаёт быть закрытой,
- роуты и страницы — часть публичного API фичи.

**3. Роутер = карта продукта**

В Angular 17+ (standalone + функциональный роутер) корневой `app.routes.ts` — это настоящая продуктовая карта приложения.

```ts
export const appRoutes: Routes = [
  { path: '', redirectTo: '/catalog', pathMatch: 'full' },
  {
    path: 'catalog',
    loadChildren: () => import('./features/catalog/catalog.routes'),
  },
  {
    path: 'cart',
    loadChildren: () => import('./features/cart/cart.routes'),
  },
  {
    path: 'order',
    loadChildren: () => import('./features/order/order.routes'),
  },
  {
    path: 'admin',
    loadChildren: () => import('./features/admin/admin.routes'),
    canMatch: [adminGuard],
  },
];
```

Открыл файл — увидел всё приложение как на ладони.

**4. Локальные роуты фичи — обязательный контракт**

Каждая фича имеет файл `feature.routes.ts` (или `catalog.routes.ts`).

Пример:

```ts
const routes: Routes = [
  {
    path: '',
    component: CatalogPage,
    title: 'Каталог товаров',
    data: { pageId: 'catalog-list', layout: 'default' },
  },
  {
    path: ':id',
    component: ProductDetailsPage,
    title: 'Карточка товара',
    data: { pageId: 'product-details', layout: 'default' },
  },
];

export default routes;
```

Фича сама определяет свои пути и метаданные.  
Роутер становится самодокументируемым.

**5. Страница — композиционный слой, а не логика**

Правильная страница содержит минимум кода.

```ts
@Component({
  standalone: true,
  imports: [CatalogComponent, AsyncPipe],
  template: `
    <app-catalog-ui 
      [products]="products$ | async"
      (addToCart)="facade.addToCart($event)"
    />
  `,
})
export class CatalogPage {
  products$ = this.facade.products$;
  constructor(private facade: CatalogFacade) {}
}
```

Страница:

- инжектит фасад,
- подписывается на сигналы,
- компонует UI-компоненты,
- передаёт данные вниз.

Всё.

Никаких HTTP, никаких вычислений, никакой бизнес-логики.

**6. Layout как часть контракта страницы**

```ts
data: { layout: 'default' | 'admin' | 'empty' }
```

Layout живёт в shared или core:

```
/shared/layouts
  default-layout.component.ts
  admin-layout.component.ts
  auth-layout.component.ts
```

И в роутере:

```ts
{
  path: 'admin',
  loadChildren: () => import('./features/admin/admin.routes'),
  data: { layout: 'admin' },
}
```

Единый визуальный каркас без дублирования.

**7. Как искать страницы в большом проекте**

В type-based ты тратишь жизнь на поиск `OrdersPageComponent` по всему проекту.

В feature-based:

```
features/order/pages/order-list.page.ts
features/order/pages/order-success.page.ts
```

Маршрут = путь к файлу.  
Всё.

**8. Lazy-loading по фичам — по умолчанию**

Если фича автономна — она обязана лениво грузиться.

```ts
loadChildren: () => import('./features/catalog/catalog.routes')
```

Результат:

- первый бандл ≤ 200–300 KB
- гидрация только нужных частей
- SSR работает идеально

**9. Метаданные страницы — скрытая суперсила**

Добавьте в каждый маршрут:

```ts
data: { 
  pageId: 'catalog-list',
  analytics: { category: 'catalog' },
  preload: true 
}
```

Теперь можно:

- автоматически строить карту приложения (да,
- делать аналитику переходов,
- генерировать sitemap,
- автоматически настраивать A/B-тесты.

**Итог главы  playing 5**

Сигнал  
Страницы переехали из «папки с компонентами» в «вход в фичу».  
Роутер превратился в читаемую карту продукта.

Ключевая парадигма 2025  
Роутер = карта приложения + страницы внутри фич + lazy-loading + метаданные.

Системные последствия  
- Исчезают «потерянные в проекте странички»  
- Онбординг сокращается до нескольких часов  
- Новичок может сам нарисовать структуру приложения по роутеру  
- Lazy-loading и SSR/SSG становятся естественными

Практические шаги прямо сейчас  
1. Удалить `src/app/pages`  
2. В каждой фиче создать `pages/` и `feature.routes.ts`  
3. Переместить все страницы в соответствующие фичи  
4. Ввести шаблон страницы (фасад + async pipe)  
5. Добавить `pageId` и `layout` в каждый маршрут

Риски  
- Ленивый разработчик кладёт страницы в `shared` — полная потеря преимуществ  
- Отказ от lazy-loading ради «быстрее пока» убивает перформанс 2025 года

Что следить в 2025–2026  
- Angular 19+ улучшит маршрутизацию (partial hydration)  
- Плагины и схемы автоматического генерации карты приложения  
- Новые подходы к маршрутизации server-first (Qwik, Angular Analog, Angular DevKit schematics)