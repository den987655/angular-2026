**ГЛАВА 3.**  
Feature-ориентированная архитектура: от принципов до реальной структуры

Feature-ориентированный подход — это не «новая мода» и не рекомендация Angular Team.  
Это точка эволюционного отбора: единственный способ удерживать сложность под контролем, когда приложение превращается в маленькую операционную систему.

Когда проект растёт, разделение по типам файлов («pages/», «components/», «services/», «models/») ломается первым. Файлы расползаются, логика дублируется, контекст теряется, новичок тратит недели на понимание.  
Feature-архитектура решает проблему фундаментально: мы группируем код по смыслу, а не по технической роли.

Эта глава — про то, что такое фича как архитектурная единица, как её правильно строить и почему именно она стала стандартом де-факто в 2025 году.

**1. Что такое «фича» в контексте архитектуры**

Фича — это самостоятельный, логически завершенный кусок продукта, который решает одну пользовательскую задачу.

Она обладает всеми необходимыми частями:

- собственный UI (страницы + компоненты),
- собственное состояние (если требуется),
- собственная интеграция с API,
- собственные модели и бизнес-правила,
- чёткий публичный интерфейс (фасад).

Примеры фич интернет-магазина:

- Каталог товаров  
- Корзина  
- Оформление заказа  
- Личный кабинет  
- Авторизация  
- Поиск  
- Избранное  
- Отзывы и рейтинг

Каждая фича автономна.  
Она ничего не знает о других фичах и взаимодействует с ними только через публичные контракты.

**2. Почему feature-based стал стандартом в 2025**

2.1. Взрывная сложность приложений  
Современные SPA — это уже не сайты, а целые цифровые продукты с сотнями экранов и состояний. Горизонтальное разделение по типам файлов перестаёт масштабироваться уже на 30–40 тысячах строк кода.

2.2. Горизонтальное масштабирование команд  
Когда над проектом работают 10–50 разработчиков, критически важно, чтобы каждый мог взять фичу и работать над ней, не ломая чужой код. Feature-срезы дают настоящую независимость.

2.3. Тестируемость и поддерживаемость  
Фича — это мини-модуль: состояние изолировано, эффекты контролируемы, мокать нужно только её границы.

2.4. Естественное совпадение с DDD  
Фича ≈ Bounded Context.  
Это не притянуто за уши, а реальное воплощение идеи: логически связанная область со своим языком и моделью.

**3. Четыре слоя внутри качественной фичи**

1. UI-слой  
   - страницы (*.page.ts)  
   - компоненты  
   - локальные сигналы и вычисляемые значения  
   Всё, что касается только отображения.

2. Фасад фичи (Feature Facade)  
   Главный публичный интерфейс фичи.  
   Хранит сигналы для UI (products$, loading$, error$), вызывает API, обновляет стор, управляет побочными эффектами.

3. Фичевый Store / Signal Store  
   Хранит доменное состояние фичи (список товаров, количество в корзине, статус оформления и т.д.).  
   Локален фиче → не загрязняет глобальное пространство.

4. Домен и data-access  
   - модели (Product, CartItem и т.д.)  
   - репозитории / адаптеры API  
   - мапперы DTO → Domain  
   - валидация и бизнес-правила

**4. Современный паттерн построения фичи (2025)**

Все крупные фреймворки пришли к одному и тому же шаблону:

Фреймворк → Реализация  
Angular 17+ → Standalone + Signals + @angular-architects/feature или NgRx SignalStore  
Next.js / React → app/router + Server Components + колокация  
Vue 3 / Nuxt → Composition API + фича-папки  
SvelteKit → всё изначально фича-ориентировано  
NestJS (бэк) → Module = Feature

Это не случайность. Это закономерность: код естественно группируется по смыслу.

**5. Feature + Store: почему стор теперь живёт внутри фичи**

Потому что:

- глобальный стор превращается в свалку,
- локальный стор фичи легко тестировать и переносить,
- фича становится полностью автономной,
- можно вынести фичу в отдельный пакет или микрофронтенд без боли.

Современный Angular-пример:

```
/features/cart
  /store
    cart.store.ts        // SignalStore с state, computed, methods
  cart.facade.ts          // тонкий фасад (часто не нужен)
  cart.page.ts
  cart-item.component.ts
  cart.model.ts
  cart.service.ts         // только HTTP + маппинг
```

**6. Сервисы становятся тоньше (и это хорошо)**

С появление Signal Store и фасадов сервисы перестают хранить состояние.  
Теперь сервис — это:

- чистый data-access (HTTP + маппинг),
- набор функций-утилит,
- оркестратор сложных операций (если фасада недостаточно).

Состояние → в SignalStore  
UI-логика → в компонентах или фасаде  
Доменная логика → в сторе или моделях  
HTTP → в сервисе/репозитории

**7. Как feature-подход рождает порядок**

7.1. Поиск файлов  
Хочешь починить корзину → открываешь /features/cart → всё здесь.

7.2. Онбординг  
Новичок за час понимает устройство любой фичи, потому что видит весь контекст в одном месте.

7.3. Рефакторинг и удаление  
Удалить фичу = удалить папку. Никаких «охотников за импортами» по всему проекту.

7.4. Код-ревью  
Ревьюишь только одну фичу → сразу видишь всю картину, а не кусочки по разным папкам.

**8. Реальная структура приложения (предпросмотр)**

В следующей главе мы разберём полноценную структуру большого приложения (интернет-магазин) с примерами кода и покажем, как всё это выглядит на практике.

**Итог главы 3**

Сигнал  
Разделение по типам файлов умерло на масштабе. Победила feature-ориентированная архитектура.

Ключевая парадигма 2025  
Фича — основная единица проектирования, декомпозиции и владения кодом.

Системные последствия  
- Команды масштабируются горизонтально  
- Онбординг ускоряется в разы  
- Рефакторинг и удаление фич становятся тривиальными  
- Код становится предсказуемым и локализованным  
- Тестирование упрощается радикально

Практические шаги прямо сейчас  
1. Начните переносить новые фичи в /features/...  
2. Выносите существующие страницы в отдельные фичи  
3. Внедряйте SignalStore или аналог на уровне фичи  
4. Делайте фасад обязательным публичным API фичи

Риски  
- «Фича-монстр» — когда в одну папку сваливают слишком много (решение: делить на подфичи)  
- Слишком мелкие фичи → избыточная глубина папок  
- Сохранение глобального стора для всего → убивает преимущества

Что следить в 2025–2026  
- @angular-architects/feature и аналоги  
- NgRx SignalStore эволюция  
- Инструменты автоматического рефакторинга в feature-based  
- Углубление колокации в Next.js 15+ и Nuxt 4