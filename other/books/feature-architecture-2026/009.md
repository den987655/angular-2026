**ГЛАВА 9.**  
Эволюция проекта: от маленького SPA к зрелой архитектуре

**Введение**  
Большинство архитектурных ошибок происходит не потому, что разработчик «не знает правильный подход», а потому что пытается применить сложную архитектуру слишком рано.

Маленький проект не выдерживает enterprise-подхода.  
Большой проект разваливается, если его строили как маленький.

Эволюция — не прихоть. Это единственный здоровый путь.  
Проект должен расти слоями, поднимая абстракции только тогда, когда без них уже больно.

Эта глава — дорожная карта: как выглядит правильная эволюция, какие сигналы говорят, что пора подниматься на следующий уровень, и как не убить проект преждевременной «архитектурностью».

**1. Этап 1: Маленький проект (до 10–15 страниц, 1–3 разработчика)**

Принцип: максимальная скорость и минимальный оверхед.

На этом этапе запрещено:

- любой Store (даже SignalStore),
- сложные папки и слои,
- DDD, Clean Architecture, фасады «на будущее»,
- глобальный стейт (кроме auth в сервисе).

Разрешено и нужно:

- standalone-компоненты,
- страницы в `/features`,
- один-два сервиса на фичу (они же фасады),
- локальные сигналы в компонентах.

Структура:

```
src/app/features/
  catalog/
    pages/
      catalog.page.ts
    ui/
      product-card.component.ts
      filters.component.ts
    services/
      catalog.service.ts        # фасад + API + простое состояние
  cart/
    pages/
      cart.page.ts
    ui/
      cart-item.component.ts
    services/
      cart.service.ts           # + localStorage для persistence
```

Состояние:
- UI-state — в компонентах (сигналы),
- фичевое состояние — в сервисе (сигналы + BehaviorSubject если нужно),
- глобального стора нет.

Этот этап может длиться годами, если проект остаётся маленьким.

**2. Этап 2: Средний проект (15–40 страниц, 3–8 разработчиков)**

Фичи начинают расти. Появляются кросс-компонентные зависимости. Сервисы толстеют.

Сигналы, что пора расти:

- сервис > 300 строк,
- состояние нужно переиспользовать между компонентами,
- разработчики начинают мешать друг другу,
- появляются баги из-за гонок в состоянии.

Что делаем:

1. Переходим на строгую feature-структуру (если ещё не).
2. Вводим фасады как обязательный слой.
3. Поднимаем устойчивое состояние в SignalStore (только там, где больно).
4. Выделяем domain и api в отдельные папки в крупных фичах.

Структура теперь:

```
features/catalog/
  pages/
  ui/
  services/
    catalog.facade.ts
  state/
    catalog.store.ts          # появляется только здесь
  api/
  domain/
```

Store вводим постепенно: сначала в корзине, потом в каталоге, потом в профиле.

**3. Этап 3: Большой проект (40–100+ страниц, 8–20 разработчиков)**

Проект уже продуктовая операционная система.

Сигналы перехода:

- новичок не может понять структуру за день,
- рефакторинг одной фичи ломает другую,
- SSR/SSG добавить страшно,
- глобальный сервис/state стал свалкой.

Что делаем:

1. Все фичи становятся полноценными модулями (pages + ui + state + services + api + domain).
2. SignalStore — стандарт для любой фичи с устойчивым состоянием.
3. Глобальный стор сокращаем до минимума (auth + settings).
4. Вводим строгие публичные API фич (`index.ts` с экспортами).
5. Запрещаем прямые импорты state/ui из чужих фич.
6. Подключаем SSR/SSG выборочно (каталог, товар, блог).
7. Крупные фичи делим на подфичи:

```
features/catalog/
  list/
  filters/
  recommendations/
```

**4. Этап 4: Очень большой проект (100+ страниц, несколько команд)**

Уровень крупных e-commerce, SaaS, enterprise-панелей.

Здесь уже:

- каждая фича — мини-продукт, которым владеет отдельная команда,
- строгий контроль зависимостей (eslint-plugin-import или nx enforced boundaries),
- публичные контракты фич (index.ts + документация),
- server-first по умолчанию для всех публичных страниц,
- partial hydration и @defer везде, где возможно,
- аналитика и метаданные страницы через route.data,
- глобальный стор < 20 полей.

**5. Как правильно эволюционировать (без переписывания проекта)**

Золотое правило: поднимаем абстракции постепенно и локально.

Пошагово:

1. Никогда не делаем «полный рефакторинг архитектуры».  
   Поднимаем одну фичу → убеждаемся, что стало лучше → идём дальше.

2. Сервис → фасад → SignalStore (постепенно, по одной фиче).

3. Глобальный стор чистим постепенно: выносим корзину → каталог → профиль в свои фичи.

4. SSR включаем сначала на одной странице (например, `/catalog`), потом расширяем.

5. Подфичи создаём только когда фича > 40–50 файлов.

Это эволюция, а не революция. Проект живёт и развивается, а не уходит в рефакторинг на полгода.

**6. Сигналы, что пора на следующий этап**

Переход нужен, если есть хотя бы 2–3 пункта:

- компонент или сервис > 400 строк,
- баги появляются в неожиданных местах из-за состояния,
- новичок тратит >2 дней на онбординг,
- merge-конфликты в одном и том же файле каждый день,
- SSR добавить невозможно без боли,
- команда жалуется на «спагетти».

**7. Сигналы, что переходить рано (и будет только хуже)**

- проект < 20 страниц,
- команда ≤ 3 человека,
- нет реальных проблем с состоянием,
- бизнес-логика простая,
- SSR/SEO не нужен сейчас.

В этом случае SignalStore, фасады, domain-слой — это преждевременная сложность и тормоз разработки.

**Итог главы 9**

Сигнал  
Архитектура не навязывается с первого дня. Она растёт вместе с проектом и его болью.

Ключевая парадигма 2025  
Эволюционный рост:  
локальные сигналы → фасады → фичевые SignalStore → зрелая feature-архитектура → server-first.

Системные последствия  
- Проект не нужно переписывать каждые 2 года  
- Команда растёт без хаоса и техдолга  
- Архитектура остаётся адекватной размеру проекта  
- Долгосрочная поддержка становится реальностью

Практические шаги прямо сейчас  
1. Определите текущий этап проекта (честно).  
2. Поднимите одну самую болезненную фичу на следующий уровень.  
3. Очистите глобальный стор/сервисы от всего, что можно вынести в фичи.  
4. Добавьте SSR хотя бы на одну публичную страницу.  
5. Введите правило: новый код только по канону глав 3–8.

Риски  
- Преждевременная «enterprise-архитектура» → смерть скорости  
- Поздний переход → техдолг и боль  
- Попытка «придумать идеальную архитектуру на будущее» → всегда провал

Что следить в 2025–2026  
- Улучшения Angular DevKit для генерации фич и миграций  
- Автоматические анализаторы архитектуры (Nx, Angular ESLint rules)  
- Эволюция partial hydration и server-components подходов  
- Инструменты контроля границ фич (enforced boundaries)