**ГЛАВА 7.**  
Server-first и Angular: CSR, SSR, SSG, инкрементальная гидрация. Новый runtime фронтенда

Фичи, состояние, структура — это всё архитектура «на земле».  
Но всё это живёт внутри runtime, который определяет:

- что рендерится на сервере,  
- что — в браузере,  
- сколько JavaScript получает пользователь,  
- как быстро появляется первый кадр,  
- как работает навигация.

И вот главное изменение последних лет:  
SPA-модель больше не дефолт.  
Мир перешёл к server-first.

Раньше:  
Server → отдаёт пустую заглушку  
Client → делает всю работу

Теперь:  
Server → делает максимум возможного  
Client → только «оживляет» нужные части

Эта глава — про то, что такое server-first на практике, зачем он нужен Angular-проектам и как он идеально сочетается с feature-архитектурой.

**1. Почему чистый SPA умер**

Три убийцы:

1. Размер JS-бандла  
   Крупные приложения легко выходят за 2–4 МБ. Мобильные устройства тонут, TTI растёт до неприличия.

2. UX и бизнес-метрики  
   Белый экран до загрузки JS → высокий bounce rate.  
   Плохой SEO → потеря трафика.  
   Плохие Core Web Vitals → хуже ранжирование.

3. Глобальный тренд  
   Next.js, Remix, Qwik, SolidStart, SvelteKit, Nuxt, Astro — все топовые решения уже server-first.  
   Логика выполняется там, где это дешевле и быстрее — на сервере или на edge.

**2. Четыре режима рендеринга 2025 года**

CSR (Client-Side Rendering)  
Всё рендерится в браузере.  
Плюсы: простота разработки, нет серверной нагрузки.  
Минусы: медленный первый кадр, плохой SEO, много JS.  
Angular по умолчанию — CSR.

SSR (Server-Side Rendering)  
Первый кадр генерируется на сервере. Браузер получает готовый HTML.  
Плюсы: мгновенный FCP, отличный SEO, меньше работы клиента.  
Минусы: нужна серверная инфраструктура.  
В Angular — Angular Universal (зрелая технология с 2017, в 2025 — полностью стабильна).

SSG / Prerender (Static Site Generation)  
Страницы генерируются на этапе билда.  
Плюсы: нулевая нагрузка на сервер во время работы, максимальная скорость, идеальный SEO.  
Минусы: только для страниц без пользовательских данных.  
В Angular: `ng build --prerender` (с Angular 17+ работает отлично).

Incremental / Partial Hydration  
Ключевая фича 2024–2026 годов.  
Сервер отдаёт полностью готовый HTML.  
Клиент подгружает и гидрирует только интерактивные части страницы.

Результат:  
HTML есть сразу → пользователь видит контент  
JS минимум → Core Web Vitals в зелёной зоне

**3. Server-first — это философия, а не просто SSR**

Server-first значит:  
«Первый рендер делаем там, где это быстрее и дешевле.  
Браузеру отправляем только тот JavaScript, который действительно нужен для интерактивности».

Это включает:
- SSR,
- SSG,
- Streaming SSR,
- Partial hydration,
- Deferrable views (@defer),
- Edge rendering,
- Resumability (Qwik-подход, частично приходит в Angular).

Angular в 2025 году уже полностью server-first capable.

**4. Что реально работает в Angular прямо сейчас (ноябрь 2025)**

1. Angular Universal + Hydration — по умолчанию в новых проектах  
   `provideClientHydration()` включается одной строкой.

2. Deferrable views (@defer blocks) — с Angular 17, в 19–20 стали зрелыми  
   Позволяют лениво гидрировать части страницы.

3. Partial / Fine-grained hydration (экспериментально → стабильно в Angular 19+)  
   Гидрируются только нужные компоненты, остальное остаётся статичным HTML.

4. Prerender + Incremental Static Regeneration (ISR)  
   Angular поддерживает гибридный режим: часть страниц статика, часть SSR.

5. Image directive + встроенный lazy-loading  
   Картинки оптимизируются автоматически.

**5. Как server-first идеально сочетается с feature-архитектурой**

Это не просто «сочетается» — это сделано друг для друга.

Потому что фича:
- автономна,
- lazy-loaded,
- имеет собственные роуты,
- сама определяет свои страницы.

В server-first мире:

- Сервер видит маршрут → загружает только нужную фичу → рендерит её → отдаёт HTML.  
- Клиент получает уже готовый контент → гидрирует только интерактивные компоненты фичи.  
- Деферрабельные части фичи подгружаются по триггерам (on viewport, on interaction).

Никаких изменений в структуре папок не требуется.

**6. Как выбирать режим рендеринга для страницы/фичи**

- CSR → только для внутренних админок, дашбордов, тяжёлых редакторов  
- SSR → всё SEO-критичное: каталог, карточки товаров, блог, лендинги  
- SSG → статические разделы: «О компании», FAQ, помощь  
- Partial Hydration + @defer → страницы с большим количеством контента и частичной интерактивностью (новостная лента, профиль пользователя)

**7. Как server-first влияет на состояние**

- UI-state — только клиент (локальные сигналы)  
- Фичевое состояние — должно уметь инициализироваться на сервере (SignalStore работает в SSR без проблем)  
- Глобальное состояние — переносится через transferState или cookies  

Сигналы работают и на сервере, и на клиенте без изменений.

**8. Реальные выгоды (цифры 2025)**

- FCP: 2–4× быстрее  
- TTI: до 10× быстрее на мобильных  
- Размер JS: снижение на 60–90 % при partial hydration  
- Core Web Vitals: LCP < 1.2 с становится нормой, а не достижением  
- SEO: индексация как у обычного HTML-сайта

**9. Практическая стратегия внедрения server-first**

1. У вас уже feature-структура → полдела сделано  
2. Добавьте `provideClientHydration()` в providers  
3. Включите `@defer` там, где есть тяжёлые компоненты  
4. Разделите страницы:  
   - SEO-важные → SSR  
   - статические → prerender  
   - интерактивные внутренние → CSR  
5. Выделите client-only логику (window, localStorage) в отдельные сервисы/компоненты  
6. Настройте деплой (Vercel, Cloudflare, Angular Universal на Node/Nest)

**Итог главы 7**

Сигнал  
SPA-модель мертва. Дефолт 2025+ — server-first.

Ключевая парадигма  
Server делает максимум → Client только оживляет нужное.

Системные последствия  
- Приложения стали радикально быстрее  
- Core Web Vitals в зелёной зоне по умолчанию  
- SEO как у классического сайта  
- Меньше JavaScript → дешевле трафик, лучше мобильные устройства  
- Angular вышел на уровень топовых meta-frameworks

Практические шаги прямо сейчас  
1. Включить hydration в проекте  
2. Обернуть тяжёлые компоненты в @defer  
3. Перевести публичные страницы на SSR/prerender  
4. Измерить метрики до/после — убедиться в выигрыше

Риски  
- Плохое разделение server/client кода → краши на сервере  
- SSR без кэширования → нагрузка на сервер  
- Слишком агрессивная статика → устаревший контент

Что следить в 2025–2026  
- Стабилизация fine-grained hydration в Angular  
- Angular Analog (RSC-подход)  
- Edge runtime (Cloudflare, Deno) интеграции  
- Автоматический выбор режима рендеринга на уровне роутов