**ГЛАВА 6.**  
Состояние: UI, фича, глобальное. Сигналы, фасады, Store. Как разделить ответственность и не утонуть

Состояние — главная болевая точка всех фронтенд-проектов.

Все знакомые ужасы:

- «компонент-бог» (UI + данные + логика + временные флаги),
- «божественный стор» (всё в одном месте),
- «лёгкое приложение превратилось в Redux-ад»,
- «сервисы знают слишком много»,

— это симптомы одного: отсутствие чёткого разделения уровней состояния.

К 2025 году индустрия наконец пришла к простому и железобетонному консенсусу:

Есть три уровня состояния, и каждый решается по-своему:

UI → Фича → Глобальное.

**1. Три уровня состояния — модель, которая работает всегда**

Уровень 1. Локальный UI-state (UI-state)  
Самое простое и самое частое.

Сюда относится:

- открыт/закрыт dropdown, modal, accordion,
- текущая вкладка,
- сортировка таблицы,
- состояние формы,
- loading-спиннер на кнопке,
- временные флаги (isSubmitting, isExpanded).

Где хранить: только внутри компонента (сигналы, локальные переменные, Reactive Forms).

Правила:
- UI-state никогда не выносится в сервисы или сторы.
- Компонент — единственный источник истины для своего UI-поведения.

Уровень 2. Фичевое состояние (Feature-state)  
Состояние одной функциональной области, которое переживает пересоздание компонентов.

Примеры:

- список товаров в каталоге,
- содержимое корзины,
- выбранные фильтры,
- черновик заказа,
- текущий просматриваемый товар.

Признаки: используется несколькими компонентами фичи + должно сохраняться при навигации внутри фичи.

Где хранить: фичевый SignalStore (или NgRx SignalStore) — рекомендованный вариант 2025 года.

Допустимо: фасад с сигналами, если состояние совсем простое.

Уровень 3. Глобальное состояние  
То, что действительно нужно всем или почти всем фичам.

Примеры (и только они):

- авторизованный пользователь,
- токены,
- тема (light/dark),
- локаль,
- глобальные настройки (валюта, единицы измерения),
- конфигурации сервера (feature flags).

Глобальный стор должен быть крошечным (обычно < 10 полей) и жёстко контролируемым.

**2. Главная ошибка — инверсия или смешение уровней**

Типичные катастрофы:

- UI хранит фичевое состояние → компонент-бог,
- фича кладёт UI-state в стор → засорение и оверхед,
- глобальный стор хранит корзину, фильтры, каталог → централизованный ад,
- сервисы хранят состояние → скрытый невидимый Redux.

Правило простое:  
UI — только своё  
Фича — только своё  
Глобал — только то, что реально глобальное

**3. Сигналы — новый дефолт, но не панацея**

Сигналы идеальны для UI-уровня и большей части фича-уровня.

Где сигналы — правильный выбор:
- весь UI-state,
- простое фичевое состояние,
- вычисляемые значения на основе стора,
- реактивные формы.

Где сигналы — ошибка:
- долгоживущий бизнес-стейт, требующий строгой предсказуемости,
- кросс-фичевое состояние,
- сложные эффекты и серверная синхронизация.

Сигналы — инструмент, а не архитектура.

**4. Роль фасада в 2025 году**

Фасад (или feature service) — это оркестратор фичи, а не хранилище состояния.

Он:

- предоставляет сигналы для UI (items$, loading$, error$),
- вызывает методы стора,
- запускает эффекты (загрузка, сохранение),
- адаптирует данные под нужды UI,
- скрывает сложность.

UI работает только с фасадом.  
Фасад не хранит состояние сам — он его берёт из стора или создаёт вычисляемые сигналы.

**5. Когда Store действительно нужен (а когда нет)**

Store нужен только при наличии хотя бы одного из условий:

1. Состояние используется несколькими компонентами одной фичи  
2. Состояние должно пережить навигацию/пересоздание компонентов  
3. Требуется строгая предсказуемость изменений и DevTools  
4. Есть сложные эффекты или серверная синхронизация

Если ни одного — Store не нужен. Точка.

**6. Лестница подъёма абстракций (единственно правильная)**

Этап 1 → Только компонент + локальные сигналы  
Этап 2 → Компонент + фасад (появился API или сложная логика)  
Этап 3 → Компонент + фасад + фичевый SignalStore (появилось устойчивое состояние)  
Этап 4 → Глобальный стор (только если данные нужны другим фичам)

Подъём только вверх. Никогда вниз.

**7. Пример: корзина (эталонное разделение)**

UI-уровень:
- корзина открыта/закрыта (сигнал в компоненте),
- loading на кнопке «Оформить».

Фичевый уровень (Cart SignalStore):
- список позиций,
- количество,
- суммы,
- промокоды,
- статус синхронизации.

Фасад:
- loadCart(), addItem(), updateQuantity(), applyPromo(), checkout()

Глобальный уровень:
- текущий пользователь (чтобы знать, чья корзина)

**8. Золотые правила состояния 2025 (коротко и жёстко)**

1. UI хранит только UI.  
2. Фича хранит только фичу.  
3. Глобал — минимум, всё остальное вынести.  
4. Сервис не хранит состояние. Никогда.  
5. Store — только когда действительно нужен.  
6. Сигналы — для UI и простых фич, Store — для сложных.  
7. Поднял состояние на уровень выше — назад не возвращай.  
8. Глобальный стор должен помещаться на один экран.

**Итог главы 6**

Сигнал  
Состояние больше не централизовано. Оно распределено по трём уровням: UI → Фича → Глобал.

Ключевая парадигма 2025  
Локальный UI-state (сигналы) → Фичевый SignalStore → Минимальный глобальный стор + фасады-оркестраторы.

Системные последствия  
- Исчезают компоненты-боги и стоны-монстры  
- Каждая фича становится предсказуемой и тестируемой  
- Скорость разработки растёт в разы  
- Проект не тонет в состоянии при росте

Практические шаги прямо сейчас  
1. Провести аудит: разнести всё состояние по трём уровням  
2.  
2. Вычистить UI-компоненты от фичевого состояния.  
3. Перенести API-логику в фасады.  
4. Создать SignalStore только там, где он оправдан.  
5. Уменьшить глобальный стор в 5–10 раз.

Риски  
- Ранний переход на Store → избыточная сложность («Store ради Store»)  
- Сервисы со состоянием → скрытый хаос  
- Глобальный стор, который снова разрастается

Что следить в 2025–2026  
- NgRx SignalStore (станет стандартом)  
- Angular Signals + SSR улучшения  
- Reactive primitives нового поколения  
- Автоматические анализаторы состояния (lint-правилы)