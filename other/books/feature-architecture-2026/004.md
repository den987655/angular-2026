**ГЛАВА 4.**  
Как правильно строить фичи: структура, уровни и потоки данных

Если в предыдущей главе мы разобрали, зачем нужен feature-подход, то теперь разберём, как именно фича устроена изнутри.

Фича — это маленькое автономное приложение внутри большого.  
У неё есть свой UI, своё состояние, свой API-слой, свои модели и чёткие границы.  
Правильное внутреннее устройство фичи — это основа всей архитектуры проекта.  
Ошибка здесь всегда приводит к хаосу: запутанным зависимостям, дублированию состояния и размытым зонам ответственности.

В этой главе мы разберём фичу послойно и покажем реальный поток данных.  
Всё это станет каркасом для структуры интернет-магазина в следующих главах.

**1. Фича как автономный модуль: четыре слоя**

```text
UI (pages + components)
      ⇣ (вызовы методов)
Facade / Feature Service
      ⇣ (команды + эффекты)
Feature Store / SignalStore (часто, но не всегда)
      ⇣ (чистые модели)
Domain (models, rules, mappers)
```

Однонаправленный поток: каждый слой знает только тот, что ниже него.  
Обратная связь — только через сигналы/наблюдаемые данные.

**2. Первый слой: UI**

UI-слой занимается исключительно отображением и взаимодействием с пользователем:

- рендеринг данных,
- локальные сигналы (form state, opened dropdowns, tabs и т.д.),
- визуальные эффекты,
- события пользователя (click, input, drag & drop).

Ключевое правило: UI ничего не знает о том, «как работает мир».  
Он знает только фасад фичи.

Разделение внутри UI:
- Страницы (*.page.ts, *.routes.ts) — точка входа, роут, композиция компонентов.
- Компоненты — переиспользуемые кирпичи, dumb или с минимальной логикой.

Страница может быть сложной. Компонент обязан оставаться простым.

**3. Второй слой: Фасад (Feature Facade / Feature Service)**

Это публичный API фичи и её «контроллер».

Фасад:

- предоставляет методы действий (loadProducts(), addToCart(), applyFilters()),
- формирует сигналы для UI (products$, loading$, error$, cartItems$),
- координирует работу стора и API,
- управляет побочными эффектами,
- скрывает внутреннюю сложность от UI.

UI работает только с фасадом:

```ts
this.cartFacade.add(product);
this.cartFacade.loadCart();
this.cartItems$ = this.cartFacade.cartItems$;
```

Фасад — не бизнес-логика. Это оркестратор.

**4. Третий слой: Фичевый Store (SignalStore или классический NgRx)**

Нужен почти всегда, когда есть доменное состояние.

Отвечает за:

- хранение чистого состояния фичи,
- вычисляемые значения,
- предсказуемые обновления (patchState, reducers),
- эффекты (загрузка, сохранение),
- селекторы.

Почему локальный, а не глобальный:

- глобальный стор становится свалкой,
- фича теряет автономность,
- невозможно вынести или тестировать отдельно.

Правило 2025: 99 % состояния живёт в фичевых сторах.  
Глобальный стор — только для действительно глобальных данных (auth, theme, user preferences).

**5. Четвёртый слой: Домен**

Самый чистый слой.  
Идеально — pure TypeScript, без импортов Angular или HTTP.

Содержит:

- модели (Product, CartItem, Order),
- интерфейсы и типы,
- бизнес-правила и валидацию,
- мапперы (DTO ↔ Domain),
- адаптеры/репозиторий (преобразует сырые данные API в доменные модели).

Домен делает код самодокументируемым и переносимым.

**6. Правильный и неправильный поток данных**

Правильно:
UI → Facade → Store → Domain → API (через репозиторий)

Обратный поток только через сигналы:
Domain → Store → Facade → UI

Категорически неправильно:
- UI напрямую вызывает HttpClient
- Store знает про API
- Компоненты изменяют доменные модели напрямую
- Доменные модели импортируют Angular/CDK или RxJS

**7. Реальный поток данных: пример добавления в корзину**

1. Пользователь кликает «Добавить в корзину»  
2. UI вызывает `cartFacade.addToCart(product)`  
3. Фасад вызывает метод стора `addItem(product)`  
4. SignalStore обновляет состояние (`patchState({ items: [...oldItems, newItem] })`)  
5. Если нужно отправить на сервер → фасад запускает эффект `saveCart()`  
6. После успешного ответа → `patchState({ status: 'synced' })`  
7. UI автоматически реагирует на изменения сигналов и перерисовывается

Всё предсказуемо, тестируемо и локализовано.

**8. Фича — это не папка, а контракт**

Папка — всего лишь физическое воплощение.  
Настоящая фича — это чёткий публичный интерфейс (фасад) и строгая инкапсуляция всего остального.

**9. Как фичи правильно растут**

Не пытайтесь сразу построить идеальную четырёхуровневую структуру.

Эволюция фичи:

Этап 1 (маленькая фича)  
```
/products
  /ui
  products.page.ts
  product-list.component.ts
  products.service.ts   // сразу фасад-подобный
```

Этап 2 (появляется состояние)  
```
→ добавляем facade + domain + data-access
```

Этап 3 (сложное состояние)  
```
→ выносим состояние в SignalStore
```

Этап 4 (очень большая фича)  
```
→ делим на подфичи: list, details, filters, recommendations
```

Это естественный рост, а не «перепроектировать всё сразу всё».

**10. Преимущества правильной внутренней структуры фичи**

- Контролируемый рост без деградации  
- Полная автономность и переносимость  
- Простое тестирование (unit-тесты на каждый слой)  
- Лёгкий онбординг (новичок видит всю фичу в одном месте)  
- Чёткие границы ответственности  
- Минимум неожиданного поведения

**Итог главы 4**

Сигнал  
Фича — это не папка и не набор файлов. Это автономный модуль с чёткими слоями: UI → Facade → Store → Domain.

Ключевая парадигма 2025  
Однонаправленный поток данных + строгая инкапсуляция + фасад как единственная точка входа.

Системные последствия  
- Состояние локально и предсказуемо  
- Ошибки не распространяются между фичами  
- Фичи можно выносить в пакеты или микрофронтенды  
- Тестирование становится тривиальным  
- Команда работает параллельно без конфликтов

Практические шаги прямо сейчас  
1. Сделайте фасад обязательным для каждой новой фичи  
2. Выносите доменные модели в отдельную папку/слой  
3. Используйте SignalStore (или мини-NgRx) на уровне фичи  
4. Запретите UI прямые вызовы HttpClient  
5. Добавьте в code review чек: «Где фасад этой фичи?»

Риски  
- Слишком раннее внедрение стора (когда хватает фасада)  
- Фасад-монстр (всё сваливать в один класс)  
- Дублирование состояния (и в сторе, и в фасаде)

Что следить в 2025–2026  
- Эволюция NgRx SignalStore (упрощение эффектов)  
- @angular-architects/feature-package и готовые шаблоны  
- Автоматическая генерация фасадов и сторов через schematics  
- Углубление partial hydration для фичевых роутов